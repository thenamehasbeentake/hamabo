## 在纠删码这一层做io 合并的原因
1. io合并本身：
    - 减少网络传输次数，减少brick那边系统调用次数
    - 可以把一些随机读写 合并在一起 某些随机读写能变成顺序读写
2. 纠删码
    - 纠删码是基于条带的设计，读写的基本单位是条带块。由于读写操作起始结束位置并不一定刚好覆盖完整的条带块，对于不完整的条带块还是会读出完整的条带快，解码之后在做文件偏移，只取其中一部分。顺序读写操作的开始和结束、以及随机读写更容易发生这种读惩罚的现象，发生这种情况时的io块会比理想中的小一些。io合并之后小io会合成大io，读惩罚无效操作在单个op中占比变小，提升性能。
    - 
3. 操作系统
    - 纠删码io操作时会做频繁的编码解码运算，而其中io混在中间。比如读操作，从brick读取数据，解码。写操作，先做读操作，再从解码完成的缓存中寻找相对位置，写入数据到缓存，wind下去。从操作系统的局部性原理可以看出来，对于编码解码这种需要cpu资源的，能保证时间局部性和空间局部性，更有利于运算的性能。
4. 硬件
    - 实际环境中服务端操作系统对gluster brick上xfs文件系统io的合并支持不够好，尤其是小io。通过在客户端纠删码这一层做文件合并，减少服务端的压力，提高性能。


## 纠删码
编码 解码
a + b = c
a + 2b = d
a + 3b = e

cde为常量，三个等式任意两个等式可以求出a和b的值。

RS纠删码，GF(2^8)域，
范德蒙行列式， 第一排0次方，一次方，二次方。。。
柯西行列式
纠删码的网络，cpu问题。cpu问题硬件支持
网路问题还在，读写修复，整个集群
修复代价太大了

LRC（Locally Repairable Codes），我理解为局部校验编码
全局校验码、局部校验码，减少网络的开支
